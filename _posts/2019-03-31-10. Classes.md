# 클래스

Dart는 mixin 기반의 상속과 클래스를 가진 객체 지향 언엉빈비다. 모든 객체는 클래스의 인스턴스이고, 모든 객체는 `Object`의 후손입니다. Mixin 기반의 상속이란, 모든 클래스가 단 하나의 부모 클래스가 있더라도 클래스의 몸통은 당얀한 클래스 계층에서 사용되어질 수 있다는 것을 의미합니다.

## 클래스 멤버 사용하기

객체는 데이터와 함수로 구성된 멤버(혹은 *메소드*와 *인스턴스 변수*라고도 불림)를 가집니다. 메소드가 호출될 때, 객체에서 호출합니다. 호출된 메소드는 해당 객체의 멤버와 메소드에 접근할 수 있습니다.

점(.)을 이용하여 인스턴스 변수나 메소드를 지시하세요.

```dart
var p = Point(2,2);

p.y = 3;

assert(p.y == 3);

num distance = p.distanceTo(Point(4,4));
```

왼쪽 피연산자가 `null`인 예외를 피하기 위해서는 `?.`를 사용하세요.

```dart
//p가 null이 아닌 경우 y값을 4로 정합니다.
p?.y = 4;
```

## 생성자 사용하기
****
*생성자*를 이용하여 객체를 만들 수 있습니다. 생성자의이름은 *클래스이름* 혹은 *클래스이름.식별자*가 될 수 있습니다. 예를 들어, 다음의 코드는 `Point()`와 `Point.fromJson()` 생성자를 이용하여 객체를만드는 것입니다.

```dart
var p1 = Point(2,2);
var p2 = Point.fromJson({'x':1, 'y':2});
```

몇몇 클래스들은 상수 생성자를 제공합니다. 상수 생성자를 이용하여 컴파일 타임 상수를 만들기 위해서는 생성자 이름 앞에 `const`키워드를 붙이세요.

```dart
var p = const ImmutablePoint(2,2);
```

두 각각의 컴파일 타임 상수를 만드는 것은, 원칙적으로 같은 인스턴스 결과를 보입니다.

```dart
var a = const ImmutablePoint(1,1);
var b = const ImmutablePoint(1,1);

assert(identical(a,b));
```

상수 문맥 내에서, 생성자나 리터럴 앞의 const를 생략할 수 있습니다. 다음의 예를 보세요.

```dart
const pointAndLine = const{
    'point': const [const ImmutablePoint(0,0)],
    'line': const [const ImmutablePoint(1,10),const ImmutablePoint(-2,11)],
};
```

처음의 const 키워드를 제외하고 모든 const를 생략할 수 있습니다.

```dart
const pointAndLine = {
    'point': [ImmutablePoint(0,0)],
    'line': [ImmutablePoint(1,10),ImmutablePoint(-2,11)]
};
```

만약 상수 생성자가 상수 문맥 밖이고, const 키워드 없이 호출되었다면, 이는 비-상수 객체를 생성합니다.

```dart
var a = const ImmutablePoint(1,1);
var b = ImmutablePoint(1,1);

assert(!identical(a,b));
```

>버전 노트: Dart2 에서 상수 문맥에서의 const 는 선택사항입니다.

## 객체의 타입 받아오기

런타임에서 객체의 타입을 가져오기 위해서는 `Type`객체를 반환하는 객체의 `runtimeType` 속성을 사용할 수 있습니다.

```dart
print('The type of a is ${a.runtimeType}');
```

지금까지, 클래스를 사용하는 법에 대해서 배웠습니다. 이 단원의 나머지는 객체를 구현하는 법에 대해서 다룹니다.

## 인스턴스 변수

다음은 인스턴스 변수를 선언하는 방법입니다.

```dart
class Point{
    num x;
    num y;
    num z=0;//초기값이 0
}
```

초기화 되지 않은 모든 인스턴스 변수들은 null값을 가집니다.

모든 인스턴스 변수들은 암묵적인 getter 메소드를 발생합니다. final이 아닌 인스턴스 변수들은 암묵적인 setter 메소드 또한 발생합니다.

```dart
class Point{
    num x;
    num y;
}

void main(){
    var point = Point();
    point.x = 4;
    assert(point.x == 4);
    assert(point.y == null);
}
```

만약 인스턴스 변수를 선언된 곳에서 초기화한다면, 인스턴스가 생성되어질 때인 생성자와 초기화 리스트를 실행하기 이전에  값이 설정됩니다.

## 생성자

클래스의 이름과 같은 이름의 메소드를 만드는 것으로 생성자를 선언할 수 있습니다.(추가로, 선택적으로, 식별자가 덧붙여진 것은 이름있는 생성자라고 불립니다.) 가장 일반적인 형태의 생성자는, 클래스의 새 인스턴스를 생성하는 발생 생성자입니다.

```dart
class Point{
    num x,y;

    Point(num x, num y){
        this.x = x;
        this.y = y;
    }
}
```

`this` 키워드는 현재 인스턴스를 의미합니다.

> 노트: 이름 충돌이 있는 경우에만 this 키워드를 사용하세요. 아닌 경우, Dart의 스타일은 this를 생략하는 것입니다.

생성자의 인자를 변수에 넘기는 것은 매우 일반적인 패턴이므로, Dart에서는 이를 쉽게 하는 신택스 슈거를 제공합니다.

```dart
class Point{
    num x, y;

    Point(this.x, this.y);
}
```

### 기본 생성자

만약 생성자를 정의하지 않았다면, 기본 생성자가 제공됩니다. 기본 생성자는 인자를 받지 않고 부모 클래스의 인자 없는 생성자를 호출합니다.

### 생성자는 상속되지 않습니다
하위 클래스들은 그들의 상위 클래스들의 생성자를 상속받지 않습니다. 생성자가 정의되지 않은 하위 클래스는 기본 생성자만을 가집니다.

### 이름있는 생성자
이름있는 생성자를 이용하여 보다 명확함을 제공하거나 복수의 생성자를 구현하세요
```dart
class Point{
    num x,y;
    Point(this.x,this.y);

    Point.origin(){
        x=0;
        y=0;
    }
}
```
생성자가 상속되지 않음을 기억하세요. 이는 상위클래스의 이름있는 생성자가 하위클래스에 상속되지 않음을 의미합니다. 만약 상위클래스에서 정의된 이름있는 생성자를 이용하여 하위클래스를 생성하고 싶다면, 반드시 하위 클래스에 그 생성자를 구현하여야 합니다.

### 기본 생성자가 아닌 상위 클래스의 생성자 호출하기

기본적으로, 하위 클래스의 생성자는 상위 클래스의 이름없는, 인자없는 생성자를 호출합니다. 상위 클래스의 생성자는 생성자의 몸체의 처음에 호출되어집니다. 만약 초기화 리스트가 같이 사용되었다면, 이는 상위클래스의 생성자가 호출되기 이전에 수행됩니다. 요약하면, 수행 순서는 다음과 같습니다.

1. 초기화 리스트
2. 상위클래스의 인자없는 생성자
3. 현재 클래스의 인자없는 생성자

만약, 상위 클래스가 이름이 없고, 인자가 없는 생성자를 가지고 있지 않다면, 반드시 상위 클래스의 생성자 중 하나를 호출하여야 합니다. 상위클래스의 생성자를 생성자의 몸체 앞에 `콜론(:)`을 이용하여 반드시 정의하세요.

>경고: 상위 클래스의 생성자의 인자들은 `this`의 접근 권한이 없습니다. 예를 들어, 인자들은 정적 메소드를 호출 할 수 있지만, 인스턴스 메소드를 호출할 수 는 없습니다.

### 초기화 리스트

상위 클래스의 생성자를 호출하면, 생성자의 몸체가 수행되기 전에 객체의 값을 초기화 할 수 있습니다. 초기화 값을 콤마를 이용하여 구분하세요.

```dart 
Point.fromJson(Map<String,num>json){
    : x = json['x'],
      y = json['y']{
        print('In Point.fromJson(): ($x, $y));
    }
}
```

>경고: 초기화 값의 오른쪽 피연산자는 `this`의 접근 권한이 없습니다.
개발 도중, 초기화 리스트의에 `assert`를 넣음으로써 값을 검증할 수 있습니다.
```dart
Point.withAssert(this.x,this.y): assert(x>=0){
    print('In Point.withAssert(): ($x, $y));
}
```
초기화 리스트는 상수 필드를 설정할 때에 편리합니다. 

### 생성자 리디렉션

때로는 생성자의 목적이 같은 클래스의 다른 생성자를 호출하는 것이 유일할 수 있습니다. 리디렉팅 생성자의 몸체는 비어있으며, 콜론 이후에 생성자를 호출합니다.
```dart
class Point{
    num x,y;

    Point(this.x,this.y);
    Point(alongXAxis(numx)):this(x,0);
}
```
### 상수 생성자